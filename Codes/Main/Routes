// Základní oběh od načtení chladiče pro oběh nad ním
void basicRoute(){
  tlacitka();
  // Časovač + oběh
  if(runallowed){
    // 0 - Načtení nulového bodu
    if(poradnik == 0){
      if(initializeLocation('Z') == 1){
        initializeLocation('Z');
        previousMillis = millis();
      }

      if((initializeLocation('Z') == 0)&&(digitalRead(koncak1))&&(digitalRead(koncak3))){
        if(previousMillis+200 < millis()){
          phase2 = 0;
          poradnik = 1;
        }
      }
    }
    // 1 - Nalezení kruhového chladiče
    if(poradnik == 1){
      // Inicializace, zda byl chladič již měřen. Pokud ne, nájezd do výchozí pozice pro osu X.
      if (phase2==0){
        if((strd[0][0] != 0)&&(strd[0][1] != 0)){
          poradnik = 2;
        }
        if(Yaxis1.currentPosition()!=1000){
          motorStep('Y',1000,2500);
        }
        if(Yaxis1.currentPosition()==1000){
          motorStop('Z');
          phase2=1;
        }
      }
      // Pokud je v této výchozí pozici měřič již nad chladičem, přesune se na opačnou stranu po ose Y.
      if (phase2==1){
        if(digitalRead(senzor)==0){
          phase2 = 2;
        }
        if(digitalRead(senzor)==1){
          phase2 = 3;       
        }
      }
      // Přesun na opačnou stranu (jen pokud byla minulá kontrola pozitivní)
      if (phase2==2){
        if(Yaxis1.currentPosition()!=25000){
          motorStep('Y',25000,2500);
        }
        if(Yaxis1.currentPosition()==25000){
          motorStop('Y');
          phase2=1;
        }
      }
      // Jede dokud nezaznamená hranu, ta bude prvním bodem pro osu X
      if (phase2==3){
        if(digitalRead(senzor)==1){
          motorStep('X',Xaxis.currentPosition()+(100),2500);
          previousMillis=millis();
        }
        if(digitalRead(senzor)==0){
          if(previousMillis+50<millis()){
            merX[0] = Xaxis.currentPosition();
            phase2=4;  
          } 
        } 
        if(Xaxis.currentPosition()==27750){
          phase2 = 35;
        }
      }
      if (phase2==35){
        if(Xaxis.currentPosition()!=0){
          motorStep('X',0,2500);
        }
        if(Xaxis.currentPosition()==0){
          motorStop('X');
        }
        if((Yaxis1.currentPosition()!=25000)&&(Xaxis.currentPosition()==0)){
          motorStep('Y',25000,2500);
        }
        if((Yaxis1.currentPosition()==25000)&&(Xaxis.currentPosition()==0)){
          motorStop('Y');
          phase2=3;
        }
      }
      // Přejede na opačnou stranu na ose X
      if (phase2==4){
        if((digitalRead(koncak2)==0) or (Xaxis.currentPosition()<(27500))){
          motorStep('X',207500,2500);
        }
        if((digitalRead(koncak2)==1) or (Xaxis.currentPosition()>=(27500))){
          motorStop('X');
          phase2 = 5;
        }      
      }
      // Vrací se do zaznamenání hrany = druhý bod pro X a dopočítá střed pro osu X
      if (phase2==5){
        if(digitalRead(senzor)==1){
          motorStep('X',Xaxis.currentPosition()-(100),2500);
          previousMillis=millis();
        }
        else if(digitalRead(senzor)==0){
          if(previousMillis+50<millis()){
            merX[1] = Xaxis.currentPosition();
            if((merX[1] - merX[0])<500){
              phase2=35;
            }
            strd[0][0] =merX[0] + ((merX[1] - merX[0])/2);
            phase2=6;
          }  
        }
      }
      // Vynulování Y
      if (phase2==6){
        if(initializeLocation('Y') == 1){
        initializeLocation('Y');
        }

        if(initializeLocation('Y') == 0){
          phase2=7;
        }
      }
      // Nájezd do výchozího bodu pro osu Y.
      if (phase2==7){/*
        if(Xaxis.currentPosition()!=(27500)){
          motorStep('X',27500,2500);
        }
        if((Xaxis.currentPosition()==(27500))or(digitalRead(koncak4)==1)){
          motorStop('X');*/
          phase2=8;
        //}
      }
      // Rozcestník, pokud již je nad chladičem, přejede po ose X na opačnou stranu.
      if (phase2==8){
        if(digitalRead(senzor)==0){
          phase2 = 9;
        }
        if(digitalRead(senzor)==1){
          phase2 = 10;       
        }
      }
      // Příjezd na opačnou stranu po X (jen pokud byla minulá podmínka splněna)
      if (phase2==9){
        if(Xaxis.currentPosition()!=4000){
          motorStep('X',4000,2500);
        }
        if(Xaxis.currentPosition()==4000){
          motorStop('X');
          phase2=8;
        }
      }
      // Jede po Y dokud nenarazí na hranu = první měřící bod pro osu Y
      if (phase2==10){
        if(digitalRead(senzor)==1){
          motorStep('Y',Yaxis1.currentPosition()+(100),2500);
          previousMillis=millis();
        }
        if(digitalRead(senzor)==0){
          if(previousMillis+50<millis()){
            merY[0] = Yaxis1.currentPosition();
            phase2=11;
          }  
        }          
      }
      // Přejede na druhou stranu po ose Y
      if (phase2==11){
        if(Yaxis1.currentPosition()!=26100){
          motorStep('Y',26100,2500);
        }
        if(Yaxis1.currentPosition()==26100){
          motorStop('Y');
          phase2 = 12;
        }      
      }
      // Vrací se po ose Y dokud nenarazí na hranu což je druhým bodem pro osu Y, z něhož dopočítá střed na Y.
      if (phase2==12){
        if(digitalRead(senzor)==1){
          motorStep('Y',Yaxis1.currentPosition()-(100),2500);
          previousMillis=millis();
        }
        if(digitalRead(senzor)==0){
          if(previousMillis+50<millis()){
            merY[1] = Yaxis1.currentPosition();
            strd[0][1] =merY[0] + ((merY[1] - merY[0])/2);
            phase2=13; 
          } 
        }    
      }
      // Najede na ose X na změřený střed
      if (phase2==13){
        if(Xaxis.currentPosition()!=(strd[0][0]-(offsetX))){
          motorStep('X',(strd[0][0]-(offsetX)),2500);
        }
        if(Xaxis.currentPosition()==(strd[0][0]-(offsetX))){
          motorStop('X');
          phase2=14;
        }
      }
      // Najede na ose Y na změřený střed (+offset z důvodu posunutí senzoru) a po pauze pokračuje dál.
      if (phase2==14){
        if(Yaxis1.currentPosition()!=(strd[0][1]-(offsetY))){
          motorStep('Y',(strd[0][1]-(offsetY)),2500);
          previousMillis = millis();
        }
        if(Yaxis1.currentPosition()==(strd[0][1]-(offsetY))){
          motorStop('Y');
          if(previousMillis + 1000 < millis()){
            Serial.print("\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n");
          Serial.print("X otvoru ");
          Serial.print("0");
          Serial.print(": ");
          Serial.println(strd[0][0]);
          Serial.print("Y otvoru ");
          Serial.print("0");
          Serial.print(": ");
          Serial.println(strd[0][1]);
          Serial.print("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n");
            poradnik = 2;
          }
        }
      }
    } 
    // 2 - Měřicí oběh nad chladičem
    if(poradnik == 2){
      // Najetí nulového bodu
      if(phase3 == 0){
        if(initializeLocation('Z') == 1){
          initializeLocation('Z');
        }
        if(initializeLocation('Z') == 0){
          phase3 = 1;
        }
      }
      // Krokování do bodu kdy nalezne otvor ve chladiči
      if(phase3 == 1){
        // Krokování + měření v ose X
        if((not digitalRead(koncak1)) or (not digitalRead(koncak2))){
          if(digitalRead(senzor)==0){
            motorStep('X',Xaxis.currentPosition()+((smerX)*(grid)),3566);
          }
          if(digitalRead(senzor)==1){
            if((sq((Xaxis.currentPosition())-(strd[0][0]))) + (sq((Yaxis1.currentPosition())-(strd[0][1])))<=(sq(14000))){
              phase = 0;
              poradnik = 3;
            }
            if((sq((Xaxis.currentPosition())-(strd[0][0]))) + (sq((Yaxis1.currentPosition())-(strd[0][1])))>(sq(14000))){
              motorStep('X',Xaxis.currentPosition()+((smerX)*(grid)),3566);
            }           
          }
        }
        // Krok dále v ose Y a otočení směru při naražení hrany v ose X
        if((digitalRead(koncak2)) && (smerX == 1)){
          motorStep('Y',Yaxis1.currentPosition()+(grid),2500);
          if((Yaxis1.currentPosition()%(grid)) == 0){
            motorStop('Y');
            smerX = -1;
          }
        }
        // Krok dále v ose Y a otočení směru při naražení hrany v ose X
        if((digitalRead(koncak1)) && (smerX == -1)){
          motorStep('Y',Yaxis2.currentPosition()+(grid),2500);
          if((Yaxis1.currentPosition()%(grid)) == 0){
            motorStop('Y');
            smerX = 1;
          }
        } 
        // Koncový bod, konec oběhu 
        if((digitalRead(koncak4)) &&(digitalRead(koncak2))){
          motorStop('Z');
          valB = 1;
          valG = 0;
        }
      }
    }
    // 3 - Měřicí oběh nad otvorem
    if(poradnik == 3){
      // Načtení výchozího bodu a inicializace.
      if(phase == 0){
        if(digitalRead(senzor)==1){
          motorStop('Z'); 
          lastPos[0] = Xaxis.currentPosition();
          lastPos[1] = Yaxis1.currentPosition();
          phase = 1;  
        } 
      }
      // Najetí kousek od kraje což bude využíváno jako výchozí bod.
      if(phase == 1){
        if(Xaxis.currentPosition()!=(lastPos[0]+((smerX)*1000))){             
          motorStep('X',Xaxis.currentPosition()+((smerX)*1000),2500);
        }
        else{
          motorStop('X');
          phase=2;
        }       
      } 
      // Pokud je mimo otvor, tento průjezd byl příliž krátký a bude ignorován. Pokud nad otvorem, začne měřit.
      if(phase == 2){
        if(digitalRead(senzor)==0){
          poradnik = 2;
        }
        if(digitalRead(senzor)==1){
          phase = 3;
        }
      }
      // Jede ve směru dokud nenarazí na hranu = Bod 1 na X.
      if(phase == 3){
        if(digitalRead(senzor)==1){
          motorStep('X',Xaxis.currentPosition()+((smerX)*(100)),2500);
          lastPosWD[0]=Xaxis.currentPosition();    
          previousMillis=millis();  
        }
        if(digitalRead(senzor)==0){
          if(previousMillis+50<millis()){
            motorStop('X');
            for(int i=0; i<17; i++){
              mathValX = sq((lastPos[0]+((smerX)*1000))-strd[i][0]);
              mathValY = sq(lastPos[1]-strd[i][1]);
              if(mathValX + mathValY<=(sq(1950))){
                poradnik = 2;
              }
            }
            merX[0] = lastPosWD[0]; 
            lastPosWD[0]=0;    
            phase=4;
          }
        }
      }
      // Jede zpět proti směru až na výchozí bod měření.
      if(phase == 4){
        if(Xaxis.currentPosition()!=(lastPos[0]+((smerX)*1500))){
          motorStep('X',(lastPos[0]+((smerX)*1500)),2500);
        }
        else{
          motorStop('X');
          phase=5;
        }        
      }
      // Jede ve směru dokud nenarazí na hranu = Bod 2 na X.
      if(phase == 5){
        if(digitalRead(senzor)==1){
          motorStep('X',Xaxis.currentPosition()-((smerX)*(100)),2500);
          lastPosWD[0]=Xaxis.currentPosition();  
          previousMillis=millis();    
        }
        if(digitalRead(senzor)==0){
          if(previousMillis+50<millis()){
            motorStop('X');
            merX[1] = lastPosWD[0]; 
            phase=6;
          }   
        }        
      }
      // Dopočítání středu na ose X.   
      if(phase == 6){
        if((merX[0]!=0) && (merX[1]!=0) && (merX[0]!=merX[1])){
          if((abs(merX[1] - merX[0])) <= 500){
            poradnik =2;
          }
          if((abs(merX[1] - merX[0])) > 500){
            strd[strdporadi][0]=merX[0] + ((merX[1] - merX[0])/2);
            phase = 7; 
          } 
        }
        else{

          poradnik = 2;
        }       
      }
      // Najetí středu na ose X.
      if(phase == 7){
        if(Xaxis.currentPosition()!=(strd[strdporadi][0]-(offsetX))){
          motorStep('X',(strd[strdporadi][0]-(offsetX)),2500);
          previousMillis = millis();
        }
        if(Xaxis.currentPosition()==(strd[strdporadi][0]-(offsetX))){
          motorStop('X');
          if(previousMillis + 100 < millis()){
            phase = 8;
          }
        }
      }
      // Jede dolů ve směru Y až po hranu, nalezení prvního bodu pro osu Y.
      if(phase == 8){
        if(digitalRead(senzor)==1){
          motorStep('Y',Yaxis1.currentPosition()-(100),2500);
          lastPosWD[1] = Yaxis1.currentPosition();
        }
        if((digitalRead(senzor)==0) or (digitalRead(koncak3))){
          merY[0] = lastPosWD[1];
          lastPosWD[1] = 0;
          phase=9; 
        }        
      }
      // Návrat na pomyslný výchozí bod v Y.
      if(phase == 9){
        if(Yaxis1.currentPosition()!=lastPos[1]){
          motorStep('Y',lastPos[1],2500);
        }
        if(Yaxis1.currentPosition()==lastPos[1]){
          phase=10;  
        }        
      }
      // Nalezení druhého bodu pro osu Y a dopočítání středu.
      if(phase == 10){
        if(digitalRead(senzor)==1){
          motorStep('Y',Yaxis1.currentPosition()+(100),2500);
          lastPosWD[1] = Yaxis1.currentPosition();
        }
        if((digitalRead(senzor)==0) or (digitalRead(koncak4))){
          merY[1] = lastPosWD[1];
          strd[strdporadi][1]=merY[0] + ((merY[1] - merY[0])/2);
          phase=12; 
        }        
      }
      // Návrat na X na opačnou hranu výchozímu bodu.
      if(phase == 12){
        if(Yaxis1.currentPosition()!=lastPos[1]){
          motorStep('Y',lastPos[1],2500);
        }
        if(Yaxis1.currentPosition()==lastPos[1]){
          motorStop('Y');
          phase=14;
        }          
      }
      // Návrat na Y do výchozího bodu.
      if(phase == 13){
        if(Xaxis.currentPosition()!=merX[0]){
          motorStep('X',merX[0],2500);
        }
        if(Xaxis.currentPosition()==merX[0]){
          motorStop('X');
          phase=13;
        }
      }
      // Vynulování a ukončení měření.
      if(phase == 14){
        lastPos[0] = 0;
        lastPos[1] = 0;
        merX[0] = 0;
        merX[1] = 0;
        merY[0] = 0; 
        merY[1] = 0;
        
        Serial.print("\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n");
        Serial.print("X otvoru ");
        Serial.print(strdporadi);
        Serial.print(": ");
        Serial.println(strd[strdporadi][0]);
        Serial.print("Y otvoru ");
        Serial.print(strdporadi);
        Serial.print(": ");
        Serial.println(strd[strdporadi][1]);
        Serial.print("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n");

        strdporadi = strdporadi + 1;
      
        poradnik = 2;
      }
    }
  }
  else{
    motorStop('Z');
  }
}
